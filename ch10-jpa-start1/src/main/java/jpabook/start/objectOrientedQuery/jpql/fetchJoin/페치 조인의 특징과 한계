페치 조인을 사용하면 SQL 한 번으로 연관된 엔티티들을 함께 조회할 수 있어서 SQL 호출 횟수를 줄여
성능을 최적화할 수 있다.

@OneToMany(fetch = FetchType.LAZY)
위 처럼 엔티티에 직접 적용하는 로딩 전략을 애플리케이션 전체에 영향을 미치는 글로벌 로딩 전략이다.
페치 조인은 글로벌 로딩 전략보다 우선한다.
예를 들어 글로벌 로딩 전략을 지연 로딩으로 설정해도 JPQL에서 페치 조인을 사용하면 페치 조인을 적용해서
함께 조회한다.

"최적화를 위해 글로벌 로딩 전략을 즉시 로딩으로 설정하면 애플리케이션 전체에서 항상 즉시 로딩이 일어난다.
물론 일부는 빠를 수는 있지만 전체로 보면 사용하지 않는 엔티티를 자주 로딩하므로 오히려 성능에 악영향을
미칠 수 있다. 따라서 글로벌 로딩 전략은 될 수 있으면 지연 로딩을 사용하고 최적화가 필요한 페치 조인을
적용하는 것이 효과적이다."
또한 페치 조인을 사용하면 연관된 엔티티를 쿼리 시점에 조회하므로 지연 로딩이 발생하지 않는다.
따라서 "준영속 상태에서도 객체 그래프를 탐색할 수 있다"

페치 조인은 다음과 같은 한계가 있다.

ㅁ 페치 조인 대상에는 별칭을 줄 수 없다.
- 페치 조인에 별칭을 정의하는 내용이 없다. 따라서 SELECT, WHERE 절, 서브 쿼리에 페치 조인 대상을
사용할 수 없다.
- JPA 표준에는 지원하지 않지만 하이버네이트를 포함한 몇몇 구현체들은 페치 조인에 별칭을 지원한다.
하지만 별칭을 잘못 사용하면 연관된 데이터 수가 달라져서 데이터 무결성이 깨질 수 있으므로 조심해서
사용해야 한다.
특히 2차 캐시와 함께 사용할 때 조심해야 하는데, 연관된 데이터 수가 달라진 상태에서 2차 캐시에 저장되면
다른 곳에서 조회할 때도 연관된 데이터 수가 달라지는 문제가 발생할 수 있다.

ㅁ 둘 이상의 컬렉션을 페치할 수 없다.
구현체에 따라 되기도 하는데 컬렉션 * 컬렉션의 카테시안 곱이 만들어지므로 주의해야 한다.
하이버네이트를 사용하면 "javax.persistence.PersistenceException: org.hibernate.loader.MultipleBagFetchException: cannot simultaneously fetch multiple bags"
예외가 발생한다.

ㅁ 컬렉션을 페치 조인하면 페이징 API(setFirstResult, setMaxResults)를 사용할 수 없다.
- 컬렉션(일대다)이 아닌 단일 값 연관 필드(일대일, 다대일)들은 페치 조인을 사용해도 페이징 API를 사용할 수 있다.
- 하이버네이트에서 컬렉션을 페치 조인하고 페이징 API를 사용하면 경고 로그를 남기면서 메모리에서 페이징 처리를 한다.
데이터가 적으면 상관없겠지만 데이터가 많으면 성능 이슈와 메모리 초과 예외가 발생할 수 있어서 위험한다.

페치 조인은 SQL 한 번으로 연관된 여러 엔티티를 조회할 수 있어서 성능 최적화에 상당히 유용하다.
그리고 실무에서 자주 사용하게 된다. 하지만 모든 것을 페치 조인으로 해결할 수는 없다. 
페치 조인은 객체 그래프를 유지할 때 사용하면 효과적이다. 
반면에 여러 테이블을 조인해서 엔티티가 가진 모양이 아닌 전혀 다른 결과를 내야 한다면 억지로 페치 조인을
사용하기보다는 여러 테이블에서 필요한 필드들만 조회해서 DTO로 반환하는 것이 더 효과적일 수 있다.
