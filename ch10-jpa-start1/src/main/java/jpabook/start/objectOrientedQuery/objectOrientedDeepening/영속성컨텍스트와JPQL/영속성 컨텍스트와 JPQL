영속성 컨텍스트와 JPQL

쿼리 후 영속 상태인 것과 아닌 것
	JPQL의 조회 대상은 엔티티, 임베디드 타입, 값 타입 같이 다양한 종류가 있다.
	JPQL로 엔티티를 조회하면 영속성 컨텍스트에서 관리되지만 엔티티가 아니면 영속선 컨텍스트에 관리되지 않는다.
	예를 들면 임베디트 타입은 조회해서 값을 변경해도 변경 감지에 의한 수정이 발생하지 않는다.
	그러나 조회한 엔티티의 임베디드 타입은 수정이 가능하다.

JPQL로 조회한 엔티티와 영속성 컨텍스트
	만약 영속성 컨텍스트에 데이터가 있는 상황에서 JPQL로 해당 데이터를 조회하게 되면 조회한 엔티티가 영속성 컨텍스트에
	있기 때문에 조회한 결과를 버리고 대신에 영속성 컨텍스트에 있는 엔티티를 반환한다.
	이때 식별자 값을 사용해서 비교하게 된다.
	
	1. JQPL을 사용해서 조회를 요청한다.
	2. JPQL은 SQL로 변환되어 데이터베이스를 조회한다.
	3. 조회한 결과와 영속성 컨텍스트를 비교한다.
	4. 식별자 값을 기준으로 이미 영속성 컨텍스트에 데이터가 있으면 버리고 기존에 있던 데이터가 반환 대상이 된다.
	5. 식별자 값을 기준으로 영속성 컨텍스트에 데이터가 없으면 영속성 컨텍스트에 추가한다.
	
	ㅁ JPQL로 조회한 엔티티는 영속 상태이다.
	ㅁ 영속성 컨텍스트에 이미 존재하는 엔티티가 있으면 기존 엔티티를 반환한다.
	
	그런데 왜 데이터베이스에서 새로 조회한 데이터를 버리고 영속성 컨텍스트에 있는 기존 엔티티를 반환하는 것일까?
	JPQL로 조회한 새로운 엔티티를 영속성 컨텍스트에 하나 더 추가하거나 기존 엔티티를 새로 검색한 엔티티로 대체하면
	어떤 문제가 있는 것일까?
	
	1. 새로운 엔티티를 영속성 컨텍스트에 하나 더 추가한다.
	2. 기존 엔티티를 새로 검색한 엔티티로 대체한다.
	3. 기존 엔티티는 그대로 두고 새로 검색한 엔티티를 버린다.
	
	영속성 컨텍스트는 기본 키 값을 기준으로 엔티티를 관리한다. 따라서 같은 기본 키 값을 가진 엔티티는 등록할 수 없으므로
	1번은 아니다. 
	2번은 언뜻 합리적인 것 같지만, 영속성 컨텍스트에 수정 중인 데이터가 사라질수 있으므로 위험하다.
	영속성 컨텍스트는 엔티티의 동일성을 보장한다. 따라서 영속성 컨텍스트는 3번으로 동작한다.
	"영속성 컨텍스트는 영속 상태인 엔티티의 동일성을 보장한다" em.find로 조회하든 JPQL을 사용하든 영속성 컨텍스트가 같으면
	동일한 엔티티를 반환한다.
	
find() vs JPQL
	em.find() 메소드는 엔티티를 영속성 컨텍스트에서 먼저 찾고 없으면 데이터베이스에서 찾는다.
	따라서 해당 엔티티가 영속성 컨텍스트에 있으면 메모리에서 바로 찾으므로 성능상 이점이 있다.(그래서 1차캐시라 부른다.)
	
		// 최초 조회, 데이터베이스에서 조회
		Member member1 = em.find(Member.class, 1L);
		// 두 번째 조회, 영속성 컨텍스트에 있으므로 데이터베이스를 조회하지 않음
		Member member2 = em.find(Member.class, 1L);
		
		// member1 == member2는 주소값이 같은 인스턴스
		
	그렇다면 JPQL은 어떤 방식으로 동작할까? 다음 코드를 보자.
	
		// 첫 번째 호출 : 데이터베이스에서 조회
		Member member1 = em.createQuery("select m from Member m where m.id = :id", Member.class)
			.setParameter("id", 1L)
			.getSingleResult();
		
		// 두 번째 호출 : 데이터베이스에서 조회
		Member member2 = em.createQuery("select m from Member m where m.id = :id", Member.class)
			.setParameter("id", 1L)
			
		// member1 == member2는 주소값이 같은 인스턴스
			.getSingleResult();
	
	em.find()를 2번 사용한 로직과 마찬가지로 주소 값이 같은 인스턴스를 반환하고 결과도 같다. 하지만 내부 동작방식은 조금 다르다.
	"JPQL은 항상 데이터베이스에 SQL을 실행해서 결과를 조회한다."
	JPQL은 데이터베이스를 먼저 조회한다.
	위 코드에서 첫 번쨰 JPQL을 호출하면 데이터베이스에서 회원 엔티티(id = 1L)를 조회하고 영속성 컨텍스트에 등록한다.
	두 번째 JPQL을 호출하면 데이터베이스에서 같은 회원 엔티티(id = 1L)를 조회한다. 
	그런데 이때 영속성 컨텍스트에 이미 조회한 같은 엔티티가 있다. 
	앞서 이야기 한데로 새로 검색한 엔티티는 버리고 영속성 엔티티에 있는 기존 엔티티를 반환한다.
	
	JPQL의 특징
	ㅁ JQPL은 항상 데이터베이스를 조회한다.
	ㅁ JQPL로 조회한 엔티티는 영속 상태다.
	ㅁ 영속성 컨텍스트에 이미 존재하는 엔티티가 있으면 기존 엔티티를 반환한다.